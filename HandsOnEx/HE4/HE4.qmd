---
title: "Hands-On Exercise 4: Spatial Weights and Applications"
author:
  - name: Matthew Ho
    url: https://www.linkedin.com/in/matthewhoyiwen/
date: 01-27-2024
description: |
  Computing spatial weights with R
categories:
  - Hands-On Exercise
format:
  html:
    toc: true
execute: 
  eval: true
  echo: true
  warning: false
---
## 1.0 Overview
We're going to compute spatial weights!

## 2.0 Setup

### 2.1 Dependencies
New dependencies:
-   spdep: To create spatial weights matrix objects 

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

### 2.2 Importing Data
```{r}
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
```

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```
### 2.3 Relational Join
Update the hunan dataframe with the attributes of the hunan2012 dataframe

```{r}
hunan <- left_join(hunan,hunan2012)%>%
  select(1:4, 7, 15)
```

### 2.4 Visualising Regional Development Indicator
Back to using tmaps.

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)

gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```
## 3.0 Contiguity Spatial Weights

### 3.1 QUEEN Contiguity Based Neighbours
All-directions common boundaries

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```
Show the neighbours for polygon 1. It has 5 neighbours.
```{r}
wm_q[[1]]
```

Get the county name of polygon 1
```{r}
hunan$County[1]
```
Show names of 5 neighbours
```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```

Get GDP per capita of the 5 neighbours
```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

Show the whole weight matrix (Long)
```{r}
#| code-fold: true
#| code-summary: "Show the code"

str(wm_q)
```

### 3.2 ROOK Contiguity Based Neighbours
Up down left right
```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

Get longitude value of the centroid of each polygon in the geometry column

Get latitude value of the centroid of each polygon in the geometry column

Combine the coordinates

Show the first few rows of the coords
```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])

coords <- cbind(longitude, latitude)
head(coords)
```

### 3.3 Plotting the QUEEN Contiguity Based Neighbours Map
```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```

### 3.4 Plotting the ROOK Contiguity Based Neighbours Map
```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

### 3.5 Plotting both
```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="Queen Contiguity")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
plot(hunan$geometry, border="lightgrey", main="Rook Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

## 4.0 Computing distance based neighbours
### 4.1 Determining cut-off distance

Get a matrix of the indices of points from the set of the k nearest neighbours

Convert into a neighbours list of nb class. 

Use nbdists to get the length of neighbour relationship edges. Returns coordinate pairs if projected, otherwise kilometers

Remove the list structure with unlist 
```{r}
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

### 4.2 Computing fixed distance weight matrix
Use dnearneigh for this
```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```

Print matrix with str
```{r}
str(wm_d62)
```

Can use table() and card() to do the same but nicer
```{r}
table(hunan$County, card(wm_d62))

n_comp <- n.comp.nb(wm_d62)
n_comp$nc
```

```{r}
table(n_comp$comp.id)
```

### 4.3 Plot the fixed distance weight matrix
```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```

### 4.4 Plot 1st nearest neighbours and distance link
```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="1st nearest neighbours")
plot(k1, coords, add=TRUE, col="red", length=0.08)
plot(hunan$geometry, border="lightgrey", main="Distance link")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6)
```

## 5.0 Adaptive distance weight matrix

Can control #neighbours with k parameter. 
```{r}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6
```

Print the matrix, 6 columns
```{r}
str(knn6)
```

### 5.1 Plot distance based neighbours
```{r}
plot(hunan$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

## 6.0 Weights based on Inversed Distance Weights
Compute distances with nbdists

```{r}
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```

### 6.1 Row Standardised Weights Matrix
Assign equal weight with W.

Assign weights as 1/x where x is the no of neighbours

```{r}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q
```

Show weight of first polygon's 8 neighbours
```{r}
rswm_q$weights[10]
```

Derive row standardised distance weight matrix
```{r}
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
```

Show the weights
```{r}
rswm_ids$weights[1]
```

```{r}
summary(unlist(rswm_ids$weights))
```

## 7.0 Spatial Weight Matrix Application

Spatially lagged values: Average neighbor GDPPC value for each polygon
```{r}
GDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)
GDPPC.lag
```

Get the GDPPC for the 5 neighbours
```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

Append values to hunan dataframe
```{r}
lag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("NAME_3", "lag GDPPC")
hunan <- left_join(hunan,lag.res)
```

Show the new head
```{r}
head(hunan)
```

Plot the GDPPC and spatial lag GDPPC, the map looks more gradual
```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_gdppc <- qtm(hunan, "lag GDPPC")
tmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)
```

### 7.1 Spatial lag as a sum of neighbouring values
Assign value of 1 per neighbour
```{r}
b_weights <- lapply(wm_q, function(x) 0*x + 1)
b_weights2 <- nb2listw(wm_q, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

lag.listw: Computes lag variable from weight and GDPPC
```{r}
lag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
lag.res <- as.data.frame(lag_sum)
colnames(lag.res) <- c("NAME_3", "lag_sum GDPPC")
```

Show result
```{r}
lag_sum
```

Append lag_sum GDPPC column to hunan dataframe
```{r}
hunan <- left_join(hunan, lag.res)
```

Plot both GDPPC and Spatial Lag Sum GDPPC to compare
```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_sum_gdppc <- qtm(hunan, "lag_sum GDPPC")
tmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)
```

### 7.2 Spatial Window Average
Add diagonal element to neighbour list
```{r}
wm_qs <- include.self(wm_q)
```

Show neighbour list of area 1. 
Observe 1 added neighbour
```{r}
wm_qs[[1]]
```

Get weights with nb2listw
```{r}
wm_qs <- nb2listw(wm_qs)
wm_qs
```

Create lag variable from weight structure and GDPPC variable
```{r}
lag_w_avg_gpdpc <- lag.listw(wm_qs, 
                             hunan$GDPPC)
lag_w_avg_gpdpc
```

Convert lag variable listw to dataframe
```{r}
lag.list.wm_qs <- list(hunan$NAME_3, lag.listw(wm_qs, hunan$GDPPC))
lag_wm_qs.res <- as.data.frame(lag.list.wm_qs)
colnames(lag_wm_qs.res) <- c("NAME_3", "lag_window_avg GDPPC")
```

Use left join to attach the lag_window_avg GDPPC values
```{r}
hunan <- left_join(hunan, lag_wm_qs.res)
```

Use kable() to compare lag GDPPC and spatial window average values. Comes from knitr
```{r}
hunan %>%
  select("County", 
         "lag GDPPC", 
         "lag_window_avg GDPPC") %>%
  kable()
```

Use tmap again to plot lag_gdppc and w_ave_gdppc maps
```{r}
w_avg_gdppc <- qtm(hunan, "lag_window_avg GDPPC")
tmap_arrange(lag_gdppc, w_avg_gdppc, asp=1, ncol=2)
```

### 7.3 Spatial window sum
Use include.self() to include diagonal elements
```{r}
wm_qs <- include.self(wm_q)
wm_qs
```

Assign binary weights to neighbour structure which includes the diagonal element
```{r}
b_weights <- lapply(wm_qs, function(x) 0*x + 1)
b_weights[1]
```

nb2listw and glist to assign weight values
```{r}
b_weights2 <- nb2listw(wm_qs, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

Compute lag variable with lag.listw()
```{r}
w_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
w_sum_gdppc
```

Convert lag listw to dataframe
```{r}
w_sum_gdppc.res <- as.data.frame(w_sum_gdppc)
colnames(w_sum_gdppc.res) <- c("NAME_3", "w_sum GDPPC")
```

Left join to add w_sum GDPPC to hunan
```{r}
hunan <- left_join(hunan, w_sum_gdppc.res)
```

kable() in knitr to prepare a table for preparation
```{r}
hunan %>%
  select("County", "lag_sum GDPPC", "w_sum GDPPC") %>%
  kable()
```

tmap to visualise the difference
```{r}
w_sum_gdppc <- qtm(hunan, "w_sum GDPPC")
tmap_arrange(lag_sum_gdppc, w_sum_gdppc, asp=1, ncol=2)
```























































